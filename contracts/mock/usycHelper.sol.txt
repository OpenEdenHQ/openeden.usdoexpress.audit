// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

// imported contracts and libraries
import {BokkyPooBahsDateTimeLibrary as LibDateTime} from "bpb-dateTime/BokkyPooBahsDateTimeLibrary.sol";
import {DaylightSavingsCalendar} from "./calendars/DaylightSavingsCalendar.sol";
import {DaylightSavingsLibrary} from "./calendars/DaylightSavingsLibrary.sol";
import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
import {OwnableUpgradeable} from "openzeppelin-upgradeable/access/OwnableUpgradeable.sol";
import {ReentrancyGuardUpgradeable} from "openzeppelin-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import {SafeERC20} from "openzeppelin/token/ERC20/utils/SafeERC20.sol";
import {UUPSUpgradeable} from "openzeppelin/proxy/utils/UUPSUpgradeable.sol";

// interfaces
import {IMasterFundAdmin} from "../../interfaces/IMasterFundAdmin.sol";
import {IERC20Metadata} from "openzeppelin/token/ERC20/extensions/IERC20Metadata.sol";
import {IERC20Permit} from "openzeppelin/token/ERC20/extensions/draft-IERC20Permit.sol";
import {IYieldTokenOracle} from "../../interfaces/IYieldTokenOracle.sol";
import {IYieldToken} from "../../interfaces/IYieldToken.sol";
import {IAuthority} from "entitlements/src/interfaces/IAuthority.sol";

// errors and constants
import "entitlements/src/config/enums.sol";
import "../../config/constants.sol";
import "../../config/errors.sol";

/**
 * @title   Yield Token Teller V2
 * @author  dsshap
 * @dev     Provides liquidity for yield token/stablecoin pair.
 */
contract YieldTokenTellerV2 is OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {
    using DaylightSavingsLibrary for DaylightSavingsCalendar;
    using FixedPointMathLib for uint256;
    using LibDateTime for uint256;
    using SafeERC20 for IERC20Metadata;
    using SafeERC20 for IYieldToken;

    /*///////////////////////////////////////////////////////////////
                        Constants & Immutables
    //////////////////////////////////////////////////////////////*/

    /// @notice authority to check entitlements
    IAuthority public immutable authority;

    IYieldToken public immutable ytoken;

    uint8 private immutable _ytokenDecimals;

    IYieldTokenOracle public immutable oracle;

    uint8 private immutable _oracleDecimals;

    /// @notice Data contract encoding DST start/end timestamps through 2123.
    DaylightSavingsCalendar public immutable dst;

    address public immutable feeRecipient;

    /*///////////////////////////////////////////////////////////////
                                Events
    //////////////////////////////////////////////////////////////*/

    event Bought(
        address indexed from,
        address indexed recipient,
        uint256 amount,
        uint256 paid,
        uint256 price,
        uint256 fee
    );
    event Sold(
        address indexed from,
        address indexed recipient,
        uint256 amount,
        uint256 received,
        uint256 price,
        uint256 fee
    );
    event Transferred(address indexed recipient, address indexed token, uint256 amount);
    event FeesSet(uint256 buyFee, uint256 newBuyFee, uint256 sellFee, uint256 newSellFee);
    event AfterHourTradingSet(uint256 afterHourTrading, uint256 newAfterHourTrading);
    event DedicatedSet(address oldDedicated, address newDedicated);

    /*///////////////////////////////////////////////////////////////
                         State Variables V1
    //////////////////////////////////////////////////////////////*/
    /// @notice stable coin
    IERC20Metadata public stable;

    /// @notice decimals of stable coin
    uint8 private _stableDecimals;

    /// @notice after hour trading
    uint256 public afterHourTrading;

    /// @notice fee applied during buy
    uint256 public buyFee;

    /// @notice fee applied during sell
    uint256 public sellFee;

    /// @notice teller for a specific address
    address public dedicated;

    /*///////////////////////////////////////////////////////////////
                Constructor for implementation Contract
    //////////////////////////////////////////////////////////////*/

    constructor(address _ytoken, address _oracle, address _dst, address _authority, address _feeRecipient) initializer {
        if (_ytoken == address(0)) revert BadAddress();
        if (_oracle == address(0)) revert BadAddress();
        if (_dst == address(0)) revert BadAddress();
        if (_authority == address(0)) revert BadAddress();
        if (_feeRecipient == address(0)) revert BadAddress();

        ytoken = IYieldToken(_ytoken);
        _ytokenDecimals = ytoken.decimals();
        oracle = IYieldTokenOracle(_oracle);
        _oracleDecimals = oracle.decimals();
        dst = DaylightSavingsCalendar(_dst);
        authority = IAuthority(_authority);
        feeRecipient = _feeRecipient;
    }

    /*///////////////////////////////////////////////////////////////
                            Initializer
    //////////////////////////////////////////////////////////////*/

    function initialize(
        address _owner,
        address _stable,
        uint256 _afterHourTrading,
        uint256 _buyFee,
        uint256 _sellFee,
        address _dedicated
    ) external initializer {
        if (_owner == address(0)) revert BadAddress();
        if (_stable == address(0)) revert BadAddress();

        _transferOwnership(_owner);
        __ReentrancyGuard_init_unchained();

        stable = IERC20Metadata(_stable);
        _stableDecimals = stable.decimals();

        afterHourTrading = _afterHourTrading;

        buyFee = _buyFee;
        sellFee = _sellFee;

        dedicated = _dedicated;
    }

    /*///////////////////////////////////////////////////////////////
                            Admin Functions
    //////////////////////////////////////////////////////////////*/

    function setAfterHourTrading(uint256 _hourMinute) external {
        _assertFundAdmin();

        if (_hourMinute / 100 > 23 || _hourMinute % 100 > 59) revert BadTime();

        emit AfterHourTradingSet(afterHourTrading, _hourMinute);

        afterHourTrading = _hourMinute;
    }

    /**
     * @notice Sets fees for buying and selling
     * @dev fees are in bps, 18 decimals, max fee is 2.5%
     * @param _buy fees for buying yield token
     * @param _sell fees in selling yield token
     */
    function setFees(uint256 _buy, uint256 _sell) external {
        _assertFundAdmin();

        if (_buy > 25e17 || _sell > 25e17) revert BadFee();

        emit FeesSet(buyFee, _buy, sellFee, _sell);

        buyFee = _buy;
        sellFee = _sell;
    }

    /**
     * @notice Updates the address this teller is dedicated to
     * @param _dedicated the address of the new dedicated
     */
    function setDedicated(address _dedicated) external {
        _assertFundAdmin();

        emit DedicatedSet(dedicated, _dedicated);

        dedicated = _dedicated;
    }

    /*///////////////////////////////////////////////////////////////
                            Buy Functions
    //////////////////////////////////////////////////////////////*/

    function _buyPreview(uint256 _amount) internal view virtual returns (uint256 payout, uint256 fee, int256 price) {
        // deducting buy fee
        fee = _amount.mulDivDown(buyFee, HUNDRED_PCT);
        _amount -= fee;

        // rounding to USD decimals {2}
        uint256 stableDecimals = _stableDecimals;
        if (stableDecimals > 2) payout = _amount / 10 ** (stableDecimals - 2);
        else if (stableDecimals < 2) payout = _amount * (10 ** (2 - stableDecimals));

        // scaling to Yield Token decimals {6}
        payout *= 10 ** (_ytokenDecimals - 2);

        // current price in terms of USD
        uint256 updatedAt;
        (, price, , updatedAt, ) = oracle.latestRoundData();

        uint256 currentTime = _time(block.timestamp);
        (uint256 updatedY, uint256 updatedM, uint256 updatedD) = _time(updatedAt).timestampToDate();
        (uint256 nowY, uint256 nowM, uint256 nowD) = currentTime.timestampToDate();

        // if price was not updated today OR in after hour trading, then use next price
        uint256 afterHour = afterHourTrading;
        if (
            updatedY != nowY ||
            updatedM != nowM ||
            updatedD != nowD ||
            currentTime.getHour() > afterHour / 100 ||
            (currentTime.getHour() == afterHour / 100 && currentTime.getMinute() >= afterHour % 100)
        ) {
            price = oracle.nextPrice();
        }

        payout = payout.mulDivDown(10 ** _oracleDecimals, uint256(price));
    }

    /**
     * @notice Purchase Yield Token, pays in stablecoin
     * @dev amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will result in small stablecoin loss
     * @param _from is the address of the user buying
     * @param _amount is the amount of stablecoin to deposit
     * @param _recipient is the address of the recipient
     * @return payout amount of yield token received
     */
    function _buyFor(
        address _from,
        uint256 _amount,
        address _recipient
    ) internal virtual returns (uint256 payout, int256 price) {
        if (_amount == 0) revert BadAmount();

        // checks that caller able to call external function
        _checkPermissions();

        // skipping _checkCanReceive for recipient because ytoken checks it on mint

        uint256 fee;
        (payout, fee, price) = _buyPreview(_amount);
        if (payout == 0) revert BadAmount();

        // not checking price == 0 because tx would revert in _buyPreview when dividing by 0

        stable.safeTransferFrom(_from, address(this), _amount);
        ytoken.mint(_recipient, payout);
        if (fee > 0) stable.safeTransfer(feeRecipient, fee);

        emit Bought(_from, _recipient, payout, _amount, uint256(price), fee);
    }

    /**
     * @notice Purchase Yield Token, pays in stablecoin
     * @dev amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will result in small stablecoin loss
     * @param _amount is the amount of stablecoin to deposit
     * @param _recipient is the address of the recipient
     * @return payout amount of yield token received
     */
    function _buyForWithVerification(
        address _from,
        uint256 _amount,
        address _recipient
    ) internal virtual returns (uint256 payout) {
        uint256 balanceBefore = stable.balanceOf(address(this));
        uint256 totalSupplyBefore = ytoken.totalSupply();

        int256 price;
        (payout, price) = _buyFor(_from, _amount, _recipient);

        uint256 amount = ytoken.totalSupply() - totalSupplyBefore;
        uint256 nav = _calculateNAV(amount, price);

        // The teller stable balance should never go down after a purchase
        if (stable.balanceOf(address(this)) < balanceBefore + nav || payout != amount) revert BadAmount();
    }

    /**
     * @notice Purchase Yield Token, pays in stablecoin
     * @dev amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will result in small stablecoin loss
     * @param _amount is the amount of stablecoin to deposit
     * @return amount amount of yield token received
     */
    function buy(uint256 _amount) external nonReentrant returns (uint256 amount) {
        return _buyForWithVerification(msg.sender, _amount, msg.sender);
    }

    /**
     * @notice Purchase Yield Token, pays in stablecoin
     * @dev Yield Token transferred to the recipient.
     *      Amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will result in small stablecoin loss
     * @param _amount is the amount of stablecoin to deposit
     * @param _recipient is the address of the recipient
     * @return amount amount of yield token received
     */
    function buyFor(uint256 _amount, address _recipient) external nonReentrant returns (uint256 amount) {
        return _buyForWithVerification(msg.sender, _amount, _recipient);
    }

    /**
     * @notice Purchase Yield Token, pays in stablecoin with approval based on permit
     * @dev Yield Token transferred to the recipient.
     *      amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will result in small stablecoin loss
     * @param _from is the address of the user buying
     * @param _amount is the amount of stablecoin to deposit
     * @param _recipient is the address of the recipient
     * @param _deadline is the deadline for the permit
     * @param _v is the v value of the permit signature
     * @param _r is the r value of the permit signature
     * @param _s is the s value of the permit signature
     * @return amount amount of yield token received
     */
    function buyWithPermit(
        address _from,
        uint256 _amount,
        address _recipient,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external nonReentrant returns (uint256) {
        if (!authority.doesUserHaveRole(msg.sender, Role.System_FundAdmin) && _from != msg.sender)
            revert NotPermissioned();

        IERC20Permit(address(stable)).permit(_from, address(this), _amount, _deadline, _v, _r, _s);

        return _buyForWithVerification(_from, _amount, _recipient);
    }

    /**
     * @notice Preview a purchase of Yield Token
     * @dev amount of stablecoin is rounded down to 2 decimal places,
     *      sending more precision will be ignored
     * @dev produces the anticipated payout and fees using a price
     * @param _amount is the amount of stablecoin to deposit
     * @return payout amount of yield token received
     * @return fee taken
     * @return price used in conversion
     */
    function buyPreview(uint256 _amount) external view returns (uint256 payout, uint256 fee, int256 price) {
        (payout, fee, price) = _buyPreview(_amount);
    }

    /*///////////////////////////////////////////////////////////////
                            Sell Functions
    //////////////////////////////////////////////////////////////*/

    function _sellPreview(uint256 _amount) internal view virtual returns (uint256 payout, uint256 fee, int256 price) {
        // current price in terms of USD
        (, price, , , ) = oracle.latestRoundData();
        payout = _amount.mulDivDown(uint256(price), 10 ** _oracleDecimals);

        // scaling to cents
        payout = payout / (10 ** (_ytokenDecimals - 2));

        // scaling to stable decimals
        uint256 stableDecimals = _stableDecimals;
        if (stableDecimals > 2) {
            uint256 scale = 10 ** (stableDecimals - 2);

            payout = payout * scale;
        } else if (stableDecimals < 2) {
            uint256 scale = 10 ** (2 - stableDecimals);

            payout = payout / scale;
        }

        // deducting fee from the payout
        fee = payout.mulDivDown(sellFee, HUNDRED_PCT);
        payout -= fee;
    }

    /**
     * @notice Sells Yield Token, receives stablecoin
     * @dev total amount of yield token is rounded down to 2 decimals (cents)
     *      sending more precision will not be used in payout calculation
     * @param _amount is the amount of Yield Token to sell
     * @param _recipient is the address of the recipient
     * @return payout amount of stablecoin received
     */
    function _sellFor(uint256 _amount, address _recipient) internal virtual returns (uint256 payout, int256 price) {
        if (_amount == 0) revert BadAmount();

        // checks that caller able to call external function
        _checkPermissions();

        // checks that recipient is known user
        if (_recipient != msg.sender) _checkCanReceive(_recipient);

        uint256 fee;
        (payout, fee, price) = _sellPreview(_amount);

        if (price == 0) revert BadPrice();

        ytoken.burnFor(msg.sender, _amount);
        stable.safeTransfer(_recipient, payout);
        if (fee > 0) stable.safeTransfer(feeRecipient, fee);

        emit Sold(msg.sender, _recipient, _amount, payout, uint256(price), fee);
    }

    /**
     * @notice Sells Yield Token, receives stablecoin
     * @dev total amount of yield token is rounded down to 2 decimals (cents)
     *      sending more precision will not be used in payout calculation
     * @param _amount is the amount of Yield Token to sell
     * @param _recipient is the address of the recipient
     * @return payout amount of stablecoin received
     */
    function _sellForWithVerification(uint256 _amount, address _recipient) internal virtual returns (uint256 payout) {
        uint256 balanceBefore = stable.balanceOf(address(this));
        uint256 totalSupplyBefore = ytoken.totalSupply();

        int256 price;
        (payout, price) = _sellFor(_amount, _recipient);

        uint256 amount = totalSupplyBefore - ytoken.totalSupply();
        uint256 nav = _calculateNAV(amount, price);

        // The teller stable balance should not go lower than the NAV of the sold ytoken
        if (stable.balanceOf(address(this)) < balanceBefore - nav || _amount != amount) revert BadAmount();
    }

    /**
     * @notice Sells Yield Token, receives stablecoin
     * @dev total amount of yield token is rounded down to 2 decimals (cents)
     *      sending more precision will not be used in payout calculation
     * @param _amount is the amount of Yield Token to sell
     * @return amount amount of stablecoin received
     */
    function sell(uint256 _amount) external nonReentrant returns (uint256) {
        return _sellForWithVerification(_amount, msg.sender);
    }

    /**
     * @notice Sells Yield Token, receives stablecoin
     * @dev Stablecoin transferred to the recipient.
     *      Total amount of yield token is rounded down to 2 decimals (cents)
     *      sending more precision will not be used in payout calculation
     * @param _amount is the amount of Yield Token to sell
     * @param _recipient is the address of the recipient
     * @return amount amount of stablecoin received
     */
    function sellFor(uint256 _amount, address _recipient) external nonReentrant returns (uint256) {
        return _sellForWithVerification(_amount, _recipient);
    }

    /**
     * @notice Preview a sale of Yield Token
     * @dev Produces the anticipated payout and fees using a price.
     *      Total amount of yield token is rounded down to 2 decimals (cents)
     *      sending more precision will not be used in payout calculation
     * @param _amount is the amount of Yield Token to sell
     * @return payout amount of stablecoin received
     * @return fee taken
     * @return price used in conversion
     */
    function sellPreview(uint256 _amount) external view returns (uint256 payout, uint256 fee, int256 price) {
        (payout, fee, price) = _sellPreview(_amount);
    }

    /*///////////////////////////////////////////////////////////////
                        Liquidity Mgmt Functions
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Transfer tokens from teller to recipient
     * @param _token is the address of the token to transfer
     * @param _amount is the amount of token to transfer
     * @param _recipient is the address to send token to
     */
    function transfer(address _token, uint256 _amount, address _recipient) external virtual {
        if (_amount == 0) revert BadAmount();

        _assertFundAdmin();

        if (!authority.doesUserHaveRole(_recipient, Role.LiquidityProvider_Spot)) revert NotPermissioned();

        IERC20Metadata(_token).safeTransfer(_recipient, _amount);

        emit Transferred(_recipient, _token, _amount);
    }

    /*///////////////////////////////////////////////////////////////
                    DST & Time Conversion Functions
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Return true if it's Daylight Savings Time in New York
     */
    function isDST() public view virtual returns (bool) {
        // The DST calendar stores exact timestamps for start/end of DST in New York
        uint256 year = block.timestamp.getYear();
        (uint256 start, uint256 end) = dst.getTimestamps(year);
        return block.timestamp >= start && block.timestamp < end;
    }

    /**
     * @notice Return time in New York
     */
    function _time(uint256 _timestamp) internal view virtual returns (uint256) {
        // Adjusts datetime to US Eastern Time
        return _timestamp - (isDST() ? 4 hours : 5 hours);
    }

    /*///////////////////////////////////////////////////////////////
                        Internal Functions
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Scales ytoken NAV to the stablecoin decimals
     *
     */
    function _calculateNAV(uint256 _amount, int256 _price) internal view returns (uint256 nav) {
        nav = _amount.mulDivUp(uint256(_price), 10 ** _oracleDecimals);

        uint256 stableDecimals = _stableDecimals;
        if (_ytokenDecimals > stableDecimals) nav /= (10 ** (_ytokenDecimals - stableDecimals));
        else nav *= (10 ** (stableDecimals - _ytokenDecimals));
    }

    /**
     * @dev checks that ms.sender is fund admin
     *
     */
    function _assertFundAdmin() internal view {
        if (!authority.doesUserHaveRole(msg.sender, Role.System_FundAdmin)) revert NotPermissioned();
    }

    /**
     * @dev checks that address is able to call function on teller
     *
     */
    function _checkPermissions() internal view {
        address _dedicated = dedicated;
        if (_dedicated != address(0)) {
            if (_dedicated != msg.sender) revert NotPermissioned();
        } else {
            // checks that caller able to call external function
            if (!authority.canCall(msg.sender, address(this), msg.sig)) revert NotPermissioned();
        }
    }

    /**
     * @dev checks that address is able to call transfer function on ytoken
     *
     */
    function _checkCanReceive(address _address) internal view {
        if (!authority.canCall(_address, address(ytoken), ytoken.transfer.selector)) revert NotPermissioned();
    }

    /*///////////////////////////////////////////////////////////////
                        Override Upgrade Permission
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Upgradable by the owner.
     *
     */
    function _authorizeUpgrade(address /*newImplementation*/) internal virtual override {
        _checkOwner();
    }
}
